# Stack -> Queue
class MyQueue:
    def __init__(self):
        self.input = []
        self.output = []
        
    
    def push(self, x):
        self.input.append(x)        
    
    def pop():
        self.peek()
        return self.output.pop()
        
    def peek():
        if not self.output:
            while self.input:
                self.output.append(self.input.pop())
        return self.output[-1]
    
    def empty():
        return len(self.input) == 0 and len(self.output) == 0
        
        
# Queue -> Stack
class MyStack:
    def __init__(self):
        self.q = collections.deque()
        
    def push(self,x):
        self.q.append(x)
        
        for _ in range(len(self.q)-1):
            self.q.apppend(self.q.popleft())
    
    def pop(self):
        return self.q.popleft()
    
    def top(self):
        return self.q[0]
        
    def empty(self):
        return len(self.q) == 0


# Circular Queue
class MyCircular Queue:
    def __init__(self, k: int):
        self.q = [None] * k
        self.maxlen = key
        # p1 = front
        self.p1 = 0
        # p2 = rear 
        self.p2 = 0
    
    # enQueue(): rear 포인터 이동 
    def en_queue(self, data: int) -> bool:
        if self.q[self.q2] is None:
            self.q[self.q2] = data
            self.p2 = (self.p2 + 1) % self.maxlen
            return True
        else:
            return False 
        
    # deQueue(): front 포인터 이동 
    def de_queue(self) -> bool:
        if self.q[self.p1] is None:
            return False
        else:
            self.q[self.p1] = None
            self.p1 = (self.p1 + 1) % self.maxlen
            return True
        
    # front값 리턴
    def front(self) -> int:
        if self.q[self.p1] is None:
            return None
        else:
            return self.q[self.p1]
        
        # return -1 if self.q[self.p1] is None else self.q[self.p1]
        
    # rear값 리턴 
    def rear(self) -> int:
        if self.q[self.p2] is None:
            return None
        else:
            return self.q[self.p2]
        
        # return -1 if self.q[self.p2] is None else self.q[self.p2]
        
        
    def is_full(self) -> bool:
        return self.p1 == self.p2 and self.q[self.p1] is not None
        
    def is_empty(self) -> bool:
        return self.p1 == self.p2 and self.q[self.p1] is None

\
